<!doctype html>
<html lang="en">

<head>
  <title>NC Viewer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta charset="UTF-8" />
  <style>
     html,
     body {
      background-color: var(--vscode-editor-background);
      color: var(--vscode-editor-foreground);
      font-family: var(--vscode-font-family, sans-serif);
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
    }

    main {
      height: 100%;
      width: 100%;
    }

    .viewer {
      width: 100%;
      height: 100%;
      background: var(--vscode-editor-background);
      color: var(--vscode-editor-foreground);
      position: relative;
      display: flex;
      flex-direction: column;
      justify-content: flex-end;
    }

    .viewer-info {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 1;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      padding: 8px 12px;
      background-color: var(--vscode-sideBar-background);
      color: var(--vscode-editorWidget-foreground);
      font-family: var(--vscode-editor-font-family, monospace);
      font-size: 0.85rem;
      border: 1px solid var(--vscode-editorWidget-border);
      border-radius: 4px;
      box-shadow: 0 2px 8px var(--vscode-widget-shadow);
    }

    .viewer-info span {
      margin-bottom: 4px;
    }

    .playback-panel {
      position: absolute;
      top: 14px;
      left: 14px;
      z-index: 2;
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      background-color: var(--vscode-sideBar-background);
      border: 1px solid var(--vscode-editorWidget-border);
      border-radius: 999px;
      box-shadow: 0 4px 12px var(--vscode-widget-shadow);
    }

    .viewer-button {
      border: none;
      border-radius: 12px;
      padding: 6px 14px;
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
      color: var(--vscode-button-foreground);
      background-color: var(--vscode-button-background);
      border: 1px solid var(--vscode-button-border, var(--vscode-button-background));
      transition: background-color 0.15s ease, transform 0.1s ease;
    }

    .viewer-button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .viewer-button:not(:disabled):hover {
      transform: translateY(-1px);
      background-color: var(--vscode-button-hoverBackground, var(--vscode-button-background));
    }

    .speed-control {
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: 0.8rem;
    }

    .speed-select {
      font-size: 0.85rem;
      border-radius: 999px;
      padding: 4px 8px;
      border: 1px solid var(--vscode-input-border, var(--vscode-editorWidget-border));
      background: var(--vscode-input-background);
      color: var(--vscode-input-foreground, var(--vscode-editor-foreground));
    }

    .speed-select:focus {
      outline: 1px solid var(--vscode-focusBorder);
    }

    .speed-select option {
      background: var(--vscode-editor-background);
      color: var(--vscode-editor-foreground);
    }

    #viewerSlider {
      position: absolute;
      bottom: 18px;
      left: 50%;
      transform: translateX(-50%);
      width: 75%;
      height: 10px;
      background-color: var(--vscode-input-background);
      -webkit-appearance: none;
      appearance: none;
      border-radius: 5px;
      outline-color: var(--vscode-focusBorder);
      z-index: 1;
    }

    #viewerSlider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      background-color: var(--vscode-button-background);
      border: 1px solid var(--vscode-button-border, var(--vscode-button-background));
      border-radius: 50%;
      cursor: pointer;
    }

    #viewerSlider::-moz-range-thumb {
      width: 20px;
      height: 20px;
      background-color: var(--vscode-button-background);
      border: 1px solid var(--vscode-button-border, var(--vscode-button-background));
      border-radius: 50%;
      cursor: pointer;
    }
  </style>
</head>

<body class="dark">

  <main>
    <div class="viewer" id="viewer">
      <div class="viewer-info" id="viewerInfo">
        <span>X: <span id="posX">0.000</span></span>
        <span>Y: <span id="posY">0.000</span></span>
        <span>Z: <span id="posZ">0.000</span></span>
      </div>
      <div class="playback-panel" aria-label="Simulation playback">
        <button id="playButton" class="viewer-button" type="button" aria-pressed="false">
          Play
        </button>
        <label for="playbackSpeed" class="speed-control">
          <span>Speed</span>
          <select id="playbackSpeed" class="speed-select">
            <option value="0.25">0.25×</option>
            <option value="0.5">0.5×</option>
            <option value="1" selected>1×</option>
            <option value="2">2×</option>
            <option value="4">4×</option>
          </select>
        </label>
      </div>
      <input type="range" id="viewerSlider" min="0" max="100" value="0" step="1" />
    </div>
  </main>

  <script src="./g_code_parser.js"></script>
  <script type="importmap">
      {
        "imports": {
          "three": "./libs/three.module.js",
          "three/addons/controls/OrbitControls.js": "./libs/addons/controls/OrbitControls.js",
          "three-viewport-gizmo": "./libs/three-viewport-gizmo.js"
        }
      }
    </script>

  <script type="module">
    import * as THREE from "three";
    import { ViewportGizmo } from "three-viewport-gizmo";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";

    // VS Code API for receiving file data
    const vscode = acquireVsCodeApi();

    const viewer = document.getElementById("viewer");
    const scene = new THREE.Scene();
    scene.up.set(0, 0, 1);
    const segmentsGroup = new THREE.Group();
    scene.add(segmentsGroup);

    const startPointGeometry = new THREE.SphereGeometry(1, 32, 32);
    const startPointMaterial = new THREE.MeshBasicMaterial({ color: 0x39ff14 });
    const startPointMesh = new THREE.Mesh(startPointGeometry, startPointMaterial);
    startPointMesh.visible = false;
    scene.add(startPointMesh);

    const endPointGeometry = new THREE.SphereGeometry(1, 32, 32);
    const endPointMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
    const endPointMesh = new THREE.Mesh(endPointGeometry, endPointMaterial);
    endPointMesh.visible = false;
    scene.add(endPointMesh);

    const aspect = viewer.clientWidth / viewer.clientHeight;
    const f0 = 20000;
    const camera = new THREE.OrthographicCamera(
      (-f0 * aspect) / 2,
      (f0 * aspect) / 2,
      f0 / 2,
      -f0 / 2,
      0.1,
      2 * f0,
    );
    camera.up.set(0, 0, 1);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(viewer.clientWidth, viewer.clientHeight);
    viewer.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.mouseButtons = {
      LEFT: THREE.MOUSE.PAN,
      MIDDLE: THREE.MOUSE.ROTATE,
      RIGHT: null,
    };
    controls.screenSpacePanning = true;
    controls.zoomToCursor = true;

    const gizmo = new ViewportGizmo(camera, renderer, {
      placement: "bottom-right",
    });
    gizmo.attachControls(controls);

    let movements = [];
    let lineSegmentsMesh = null;
    let size = 0;

    window.addEventListener("message", (event) => {
      const { type, ncText, lineNumber, settings } = event.data;
      const excludeCodes = settings?.excludeCodes || [
        "G10",
        "G30",
        "G53",
        "G90",
      ];

      switch (type) {
        case "loadGCode":
          if (ncText !== undefined) {
            processGCode(ncText, excludeCodes, true);
          }
          break;

        case "cursorPositionChanged":
          highlightLineInViewer(lineNumber);
          break;

        case "contentChanged":
          if (ncText !== undefined) {
            processGCode(ncText, excludeCodes, false);
          }
          break;
      }
    });
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let isMouseDown = false;
    let mouseDownPosition = { x: 0, y: 0 };

    renderer.domElement.addEventListener("mousedown", (event) => {
      isMouseDown = true;
      mouseDownPosition.x = event.clientX;
      mouseDownPosition.y = event.clientY;
    });

    renderer.domElement.addEventListener("mouseup", (event) => {
      if (!isMouseDown) return;
      isMouseDown = false;

      const dx = event.clientX - mouseDownPosition.x;
      const dy = event.clientY - mouseDownPosition.y;
      const distanceSquared = dx * dx + dy * dy;
      const clickThreshold = 5 * 5;

      if (distanceSquared <= clickThreshold) {
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

        raycaster.params.Line.threshold = size / 100 / camera.zoom;
        raycaster.setFromCamera(mouse, camera);

        if (lineSegmentsMesh) {
          const intersects = raycaster.intersectObject(
            lineSegmentsMesh,
            false,
          );

          if (intersects.length > 0) {
            const intersect = intersects[0];
            const faceIndex = intersect.index;
            const segmentIndex = Math.floor(faceIndex / 2);

            if (segmentIndex < movements.length - 1) {
              const movement = movements[segmentIndex + 1];
              const lineIdx = movement.lineNumber || 0;

              vscode.postMessage({
                type: "highlightLine",
                lineNumber: lineIdx,
              });

              highlightLineSegmentsForLine(lineIdx);
              stopPlayback();
              slider.value = segmentIndex;
            }
          } else {
            stopPlayback();
            slider.value = 0;
            selectLineSegments(movements.length, movements.length);
          }
        }
      }
    });

    function highlightLineInViewer(lineNumber) {
      const shouldStop = !pendingPlaybackCursorSync;
      pendingPlaybackCursorSync = false;
      if (shouldStop) {
        stopPlayback();
      }
      let startIdx = -1;
      let endIdx = -1;

      for (let i = 1; i < movements.length; i++) {
        if (movements[i].lineNumber === lineNumber) {
          const segmentIdx = i - 1;
          if (startIdx === -1) startIdx = segmentIdx;
          endIdx = segmentIdx;
        }
      }

      if (startIdx !== -1 && endIdx !== -1) {
        slider.value = endIdx;
        selectLineSegments(startIdx, endIdx);
      }
    }

    function highlightLineSegmentsForLine(lineNumber) {
      let startIdx = -1;
      let endIdx = -1;

      for (let i = 1; i < movements.length; i++) {
        if (movements[i].lineNumber === lineNumber) {
          const segmentIdx = i - 1;
          if (startIdx === -1) startIdx = segmentIdx;
          endIdx = segmentIdx;
        }
      }

      if (startIdx !== -1 && endIdx !== -1) {
        selectLineSegments(startIdx, endIdx);
      }
    }
    function processGCode(gcode, excludeCodes, isInitialLoad = true) {
      stopPlayback();
      clearSceneLines();

      movements = parseGCode(gcode, undefined, excludeCodes);
      console.log("Parsed movements:", movements);

      const positions = [];
      const colorsArray = [];

      const colorFeed = new THREE.Color(colors.feedColor);
      const colorRapid = new THREE.Color(colors.rapidColor);

      for (let i = 1; i < movements.length; i++) {
        const start = new THREE.Vector3(
          movements[i - 1].X,
          movements[i - 1].Y,
          movements[i - 1].Z,
        );
        const end = new THREE.Vector3(
          movements[i].X,
          movements[i].Y,
          movements[i].Z,
        );
        const isRapid = movements[i].command === "G0";
        const color = isRapid ? colorRapid : colorFeed;

        positions.push(start.x, start.y, start.z, end.x, end.y, end.z);
        colorsArray.push(
          color.r,
          color.g,
          color.b,
          color.r,
          color.g,
          color.b,
        );
      }

      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute(
        "position",
        new THREE.Float32BufferAttribute(positions, 3),
      );
      geometry.setAttribute(
        "color",
        new THREE.Float32BufferAttribute(colorsArray, 3),
      );

      const material = new THREE.LineBasicMaterial({ vertexColors: true });
      lineSegmentsMesh = new THREE.LineSegments(geometry, material);
      segmentsGroup.add(lineSegmentsMesh);

      slider.value = 0;
      slider.max = Math.max(movements.length - 1, 0);
      selectLineSegments(movements.length, movements.length);
      updatePlaybackControlsState();
      if (isInitialLoad) {
        resetCamera();
      }
    }

    function resetCamera() {
      let box = new THREE.Box3().setFromObject(segmentsGroup);

      if (box.isEmpty()) {
        box = new THREE.Box3(
          new THREE.Vector3(-1, -1, -1),
          new THREE.Vector3(1, 1, 1),
        );
      }

      size = box.getSize(new THREE.Vector3()).length();
      const center = box.getCenter(new THREE.Vector3());

      const f = size * 1.1;
      camera.left = (-f * aspect) / 2;
      camera.right = (f * aspect) / 2;
      camera.top = f / 2;
      camera.bottom = -f / 2;
      camera.zoom = 1;
      camera.updateProjectionMatrix();

      camera.position.set(
        center.x + size * 1.1,
        center.y + size * -1.1,
        size * 1.1,
      );
      camera.lookAt(center);

      controls.target.copy(center);
      controls.update();

      addAxisLines(box);
    }

    function clearSceneLines() {
      if (lineSegmentsMesh) {
        segmentsGroup.remove(lineSegmentsMesh);
        lineSegmentsMesh.geometry.dispose();
        lineSegmentsMesh.material.dispose();
        lineSegmentsMesh = null;
      }
      startPointMesh.visible = false;
      endPointMesh.visible = false;

      const axisLines = [];
      scene.traverse((child) => {
        if (child.userData.isAxisLine) {
          axisLines.push(child);
        }
      });

      axisLines.forEach((line) => scene.remove(line));
    }

    const slider = document.getElementById("viewerSlider");
    const playButton = document.getElementById("playButton");
    const speedSelect = document.getElementById("playbackSpeed");
    let playbackTimer = null;
    const playbackBaseIntervalMs = 80;
    let playbackSpeed = parseFloat(speedSelect.value) || 1;
    let pendingPlaybackCursorSync = false;

    playButton.disabled = true;
    speedSelect.disabled = true;

    slider.addEventListener("input", (event) => {
      stopPlayback();
      updateSelectionFromSlider(event.target.value);
    });

    playButton.addEventListener("click", () => {
      if (playbackTimer) {
        stopPlayback();
      } else {
        startPlayback();
      }
    });

    speedSelect.addEventListener("change", () => {
      const selectedSpeed = parseFloat(speedSelect.value);
      if (!Number.isFinite(selectedSpeed) || selectedSpeed <= 0) {
        speedSelect.value = playbackSpeed.toString();
        return;
      }

      playbackSpeed = selectedSpeed;

      if (playbackTimer) {
        stopPlayback({ resetButton: false });
        startPlayback();
      }
    });

    function updateSelectionFromSlider(value, { emitHighlight = true, source = "user" } = {}) {
      const numericValue = parseInt(value, 10);
      if (
        Number.isNaN(numericValue) ||
        numericValue < 0 ||
        numericValue >= movements.length - 1
      ) {
        return;
      }

      selectLineSegments(numericValue, numericValue);

      if (
        emitHighlight &&
        movements[numericValue + 1] &&
        movements[numericValue + 1].lineNumber !== undefined
      ) {
        if (source === "playback") {
          pendingPlaybackCursorSync = true;
        }
        vscode.postMessage({
          type: "highlightLine",
          lineNumber: movements[numericValue + 1].lineNumber,
        });
      }
    }

    function updatePlaybackControlsState() {
      const hasMovements = movements.length > 1;
      playButton.disabled = !hasMovements;
      speedSelect.disabled = !hasMovements;
      if (!hasMovements) {
        slider.value = 0;
        stopPlayback();
      }
    }

    function startPlayback() {
      if (playbackTimer || movements.length <= 1) {
        return;
      }

      pendingPlaybackCursorSync = false;
      const maxSegmentIdx = Math.max(0, movements.length - 2);
      let currentValue = parseInt(slider.value, 10);
      if (Number.isNaN(currentValue) || currentValue >= maxSegmentIdx) {
        slider.value = 0;
        currentValue = 0;
        updateSelectionFromSlider(currentValue, { source: "playback" });
      }

      setPlayButtonState(true);

      playbackTimer = setInterval(() => {
        const maxIdx = Math.max(0, movements.length - 2);
        let sliderValue = parseInt(slider.value, 10);
        if (Number.isNaN(sliderValue)) sliderValue = 0;

        if (sliderValue >= maxIdx) {
          stopPlayback();
          return;
        }

        const nextValue = sliderValue + 1;
        slider.value = nextValue;
        updateSelectionFromSlider(nextValue, { source: "playback" });

        if (nextValue >= maxIdx) {
          stopPlayback();
        }
      }, getPlaybackDelay());
    }

    function stopPlayback({ resetButton = true } = {}) {
      if (playbackTimer) {
        clearInterval(playbackTimer);
        playbackTimer = null;
      }

      if (resetButton) {
        setPlayButtonState(false);
      }
    }

    function getPlaybackDelay() {
      const speed = playbackSpeed > 0 ? playbackSpeed : 1;
      return playbackBaseIntervalMs / speed;
    }

    function setPlayButtonState(isPlaying) {
      playButton.textContent = isPlaying ? "Pause" : "Play";
      playButton.setAttribute("aria-pressed", isPlaying ? "true" : "false");
    }

    function addAxisLines(box) {
      const marginFactor = 0.2;
      const min = box.min;
      const max = box.max;

      const axes = [
        { dir: "x", color: 0xff3653, start: min.x, end: max.x },
        { dir: "y", color: 0x8adb00, start: min.y, end: max.y },
        { dir: "z", color: 0x2c8fff, start: min.z, end: max.z },
      ];

      axes.forEach(({ dir, color, start, end }) => {
        const length = end - start;
        const margin = length * marginFactor;

        let from = new THREE.Vector3();
        let to = new THREE.Vector3();

        if (dir === "x") {
          from.set(start - margin, 0, 0);
          to.set(end + margin, 0, 0);
        } else if (dir === "y") {
          from.set(0, start - margin, 0);
          to.set(0, end + margin, 0);
        } else if (dir === "z") {
          from.set(0, 0, start - margin);
          to.set(0, 0, end + margin);
        }

        const material = new THREE.LineBasicMaterial({
          color,
          depthTest: false,
          transparent: true,
          opacity: 0.8,
        });

        const geometry = new THREE.BufferGeometry().setFromPoints([from, to]);
        const line = new THREE.Line(geometry, material);
        line.userData.isAxisLine = true;

        scene.add(line);
      });
    }

    function selectLineSegments(startIdx, endIdx) {
      if (!lineSegmentsMesh) return;

      const colorAttr = lineSegmentsMesh.geometry.attributes.color;
      const color = new THREE.Color();

      for (let i = 0; i < movements.length - 1; i++) {
        const segmentIndex = i;
        const isSelected = segmentIndex >= startIdx && segmentIndex <= endIdx;
        const isAfter = segmentIndex > endIdx;

        const isRapid = movements[i + 1].command === "G0";
        let baseColor = isRapid ? colors.rapidColor : colors.feedColor;

        if (isSelected) {
          color.setHex(colors.selectedColor);
        } else {
          if (isAfter) {
            color.setHex(colors.afterSelColor);
          } else {
            color.setHex(baseColor);
          }
        }

        const vi = segmentIndex * 2;
        colorAttr.setXYZ(vi, color.r, color.g, color.b);
        colorAttr.setXYZ(vi + 1, color.r, color.g, color.b);
      }

      colorAttr.needsUpdate = true;

      if (startIdx < movements.length - 1) {
        const startPos = new THREE.Vector3(
          movements[startIdx].X,
          movements[startIdx].Y,
          movements[startIdx].Z,
        );
        const endPos = new THREE.Vector3(
          movements[endIdx + 1].X,
          movements[endIdx + 1].Y,
          movements[endIdx + 1].Z,
        );

        startPointMesh.position.copy(startPos);
        endPointMesh.position.copy(endPos);

        startPointMesh.visible = true;
        endPointMesh.visible = true;

        document.getElementById("posX").textContent =
          movements[endIdx + 1].X.toFixed(3);
        document.getElementById("posY").textContent =
          movements[endIdx + 1].Y.toFixed(3);
        document.getElementById("posZ").textContent =
          movements[endIdx + 1].Z.toFixed(3);
      } else {
        startPointMesh.visible = false;
        endPointMesh.visible = false;
        document.getElementById("posX").textContent = "0.000";
        document.getElementById("posY").textContent = "0.000";
        document.getElementById("posZ").textContent = "0.000";
      }
    }

    let colors = {
      selectedColor: 0xffffff,
      feedColor: 0x39ff14,
      rapidColor: 0xff0000,
      afterSelColor: 0xa6a6a6,
    };

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      if (startPointMesh.visible) {
        const pointSize = (size / 200) / camera.zoom;
        startPointMesh.scale.set(pointSize, pointSize, pointSize);
        endPointMesh.scale.set(pointSize, pointSize, pointSize);
      }
      renderer.render(scene, camera);
      gizmo.render();
    }

    window.addEventListener("resize", function () {
      const viewerWidth = viewer.clientWidth;
      const viewerHeight = viewer.clientHeight;
      const newAspect = viewerWidth / viewerHeight;

      const viewSize = camera.top - camera.bottom;
      camera.left = (-viewSize * newAspect) / 2;
      camera.right = (viewSize * newAspect) / 2;
      camera.updateProjectionMatrix();

      renderer.setSize(viewerWidth, viewerHeight);
      gizmo.update();
    });

    function update3DViewColors() {
      const computedStyles = getComputedStyle(document.body);
      const tempColor = new THREE.Color();
      const getHexFromVar = (varName, fallbackColor) => {
        const colorString = computedStyles.getPropertyValue(varName).trim();
        if (!colorString) return fallbackColor;
        return tempColor.set(colorString).getHex();
      };

      // Overwrite the global colors object for the 3D view
      colors.feedColor = getHexFromVar('--vscode-editor-foreground', 0x000000);
      colors.rapidColor = getHexFromVar('--vscode-gitDecoration-modifiedResourceForeground', 0x0000ff);
      colors.selectedColor = getHexFromVar('--vscode-editor-selectionBackground', 0x888888);
      colors.afterSelColor = getHexFromVar('--vscode-editor-inactiveSelectionBackground', 0x444444);

      startPointMaterial.color.setHex(colors.feedColor);
      endPointMaterial.color.setHex(colors.rapidColor);

      // Overwrite the renderer background
      const bgColor = computedStyles.getPropertyValue('--vscode-editor-background').trim();
      renderer.setClearColor(new THREE.Color(bgColor));

      // Redraw lines with new colors if they exist
      if (lineSegmentsMesh) {
        selectLineSegments(parseInt(slider.value, 10), parseInt(slider.value, 10));
      }

      // Redraw axis lines
      const axisLines = [];
      scene.traverse((child) => { if (child.userData.isAxisLine) axisLines.push(child); });
      axisLines.forEach((line) => scene.remove(line));
      let box = new THREE.Box3().setFromObject(segmentsGroup);
      if (box.isEmpty()) box = new THREE.Box3(new THREE.Vector3(-1, -1, -1), new THREE.Vector3(1, 1, 1));
      addAxisLines(box);
    }

    // Watch for theme changes
    const observer = new MutationObserver((mutationsList) => {
      for (const mutation of mutationsList) {
        if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
          update3DViewColors();
          break;
        }
      }
    });
    observer.observe(document.body, { attributes: true });

    function runWhenStylesAreReady(callback) {
      const check = () => {
        const styles = getComputedStyle(document.body);
        const foreground = styles.getPropertyValue('--vscode-editor-foreground');
        const background = styles.getPropertyValue('--vscode-editor-background');
        if (foreground.trim() && background.trim()) {
          callback();
        } else {
          setTimeout(check, 100);
        }
      };
      check();
    }

    runWhenStylesAreReady(() => {
      update3DViewColors(); // Apply VS Code theme to 3D view
      resetCamera();
      vscode.postMessage({ type: "webviewReady" });
      animate();
    });

  </script>
</body>

</html>
